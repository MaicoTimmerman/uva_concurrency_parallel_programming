\documentclass[a4paper,12px]{article}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xifthen}
\usepackage[linesnumberedhidden, titlenotnumbered]{algorithm2e}
\usepackage{lipsum}
\usepackage{hyperref}
\usepackage{array}
\usepackage{tabularx}

\usepackage{minted}
\usepackage{caption}
\usepackage{amssymb}

\pagestyle{fancy}
\lhead{\includegraphics[width=7cm]{logoUvA}}
\rhead{\footnotesize \textsc {Report\\ \opdracht}}
\lfoot
{
    \footnotesize \studentA
    \ifthenelse{\isundefined{\studentB}}{}{\\ \studentB}
    \ifthenelse{\isundefined{\studentC}}{}{\\ \studentC}
    \ifthenelse{\isundefined{\studentD}}{}{\\ \studentD}
    \ifthenelse{\isundefined{\studentE}}{}{\\ \studentE}
}
\cfoot{}
\rfoot{\small \textsc {Page \thepage\ of \pageref{LastPage}}}
\renewcommand{\footrulewidth}{0.5pt}

\fancypagestyle{firststyle}
{
    \fancyhf{}
    \renewcommand{\headrulewidth}{0pt}
    \chead{\includegraphics[width=7cm]{logoUvA}}
    \rfoot{\small \textsc {Page \thepage\ of \pageref{LastPage}}}
}

\setlength{\topmargin}{-0.3in}
\setlength{\textheight}{630pt}
\setlength{\headsep}{40pt}

% =================================== DOC INFO ===================================

\newcommand{\titel}{POSIX Threads}
\newcommand{\opdracht}{Assignment 1}
\newcommand{\docent}{Dr. A. Pimentel}
\newcommand{\cursus}{Concurrency and Parallel Programming}
\newcommand{\vakcode}{5062COPP6Y}
\newcommand{\datum}{\today}
\newcommand{\studentA}{Robin Klusman}
\newcommand{\uvanetidA}{10675671}
\newcommand{\studentB}{Maico Timmerman}
\newcommand{\uvanetidB}{10542590}
%\newcommand{\studentC}{Boudewijn Braams}
\newcommand{\uvanetidC}{10401040}
%\newcommand{\studentD}{Govert Verkes}
\newcommand{\uvanetidD}{10211748}
%\newcommand{\studentE}{Naam student 5}
\newcommand{\uvanetidE}{UvAnetID student 5}

% ===================================  ===================================

\begin{document}
\thispagestyle{firststyle}
\begin{center}
    \textsc{\Large \opdracht}\\[0.2cm]
    \rule{\linewidth}{0.5pt} \\[0.4cm]
    {\huge \bfseries \titel}
    \rule{\linewidth}{0.5pt} \\[0.2cm]
    {\large \datum  \\[0.4cm]}

    \begin{minipage}{0.4\textwidth}
        \begin{flushleft}
            \emph{Student:}\\
            {\studentA \\ {\small \uvanetidA \\[0.2cm]}}
            \ifthenelse{\isundefined{\studentB}}{}{\studentB \\ {\small \uvanetidB \\[0.2cm]}}
            \ifthenelse{\isundefined{\studentC}}{}{\studentC \\ {\small \uvanetidC \\[0.2cm]}}
            \ifthenelse{\isundefined{\studentD}}{}{\studentD \\ {\small \uvanetidD \\[0.2cm]}}
            \ifthenelse{\isundefined{\studentE}}{}{\studentE \\ {\small \uvanetidE \\ [0.2cm]}}
        \end{flushleft}
    \end{minipage}
    ~
    \begin{minipage}{0.4\textwidth}
        \begin{flushright}
            \emph{Supervisor:} \\
            \docent \\[0.2cm]
            \emph{Course:} \\
            \cursus \\[0.2cm]
            \emph{Course code:} \\
            \vakcode \\[0.2cm]
        \end{flushright}
    \end{minipage}\\[1 cm]
\end{center}


% =================================== FRONT PAGE ===================================

\tableofcontents
\clearpage

% =================================== MAIN TEXT ===================================

\section{Introduction}

For this assignment a parallel programming solution needs to be implemented for
two problems, a wave equation simulation and the Sieve of Eratosthenes. For the
wave simulation the user can specify the amount of wave amplitude points, the
amount of steps it needs to simulate and the desired amount of threads. The
program then calculates all the wave values until it has done the specified
amount of steps.

For the Sieve of Eratosthenes the program will keep producing prime numbers with
the use of multiple threads, thus utilising parallelism, until the user decides
to send a SIGINT to terminate the program.

\section{Method}
\subsection{Wave Equation Simulation}

First the specified amount of threads need to be created, these threads will
then all start executing the function $calc\_wave$. $calc\_wave$ first checks if
there is an amplitude point in the row $t+1$ that needs calculation. This check
is done in ascending order, using a variable $current\_index$ that keeps track
of which amplitude point was the last one being calculated. $current\_index$ is
mutex locked to check and increment it before starting calculation on that
particular amplitude point, so that no two threads waste their time calculating
the same point. Once the $current\_index$ reaches the last point in the wave,
$i\_max$, threads will wait until all other threads finish their calculations.
When the row is completely finished the $current\_index$ is reset and the rows
are rotated, after which an event is generated telling all threads to restart
their routine.

\subsection{Sieve of Eratosthenes}

To find prime numbers, the Sieve of Eratosthenes algorithm is used. This
multi-threaded program uses this algorithm to find primes by filtering out
non-primes from a constant flow of natural numbers, $n \in \mathbb{N}$, that is
generated by the generator thread. In this implementation we actually opted to
skip every even number, since those are all multiples of 2. This will improve
the performance of the program a little because we need one less filter and thus
one less thread. These numbers are passed through a series of
filters by using queues. Each of these filters will have a prime assigned to
them and will filter for multiples of that prime. Any number that is not found
to be a multiple of that specific prime will be passed on to the next filter. If
there is no next filter it means that the number has to be a prime, since it has
passed through all filters and was not found to be a multiple of any previously
encountered numbers. For this newly found prime a filter will be created and its
value will be printed for the user. The passing of numbers between
threads through
the queues is done mutually exclusive, so that there can be no race conditions
in reading and writing the queues. The queues are also of a set size, so that no
starvation can occur for threads further down the chain. When a new value is
found that has to be passed to the next queue, the thread will lock its output
queue and write the value to it if there is space in the queue. The generator
thread differs slightly from other threads in that it will lock the queue only
when its empty, and completely fill it with newly generated numbers, since this
takes almost no time to do.


That the different threads do not need to wait for each other to finish
filtering. These queues have a set length, so that starvation cannot occur for
filters further down the chain. When a queue is full, that thread will wait
until the buffer has a spot again. Buffers are accessed mutually exclusive, so
that no race conditions can exist.



\section{Results}


\section{Discussion}

% =================================== REFERENCES ===================================

%\clearpage
%\bibliographystyle{unsrt}
%\bibliography{bib}

\end{document}
